import React, { useRef, useEffect } from 'react';
import styled from '@emotion/styled';
import { keyframes } from '@emotion/react';
import { Link } from 'react-router-dom';

// Cluster color palette — each cluster gets a different color (bright colors for dark background)
const CLUSTER_COLORS = [
  '#00FFE5', // Bright Cyan
  '#FF006E', // Hot Pink
  '#FFB703', // Bright Orange
  '#8338EC', // Vibrant Purple
  '#FB5607', // Vibrant Red-Orange
  '#3A86FF', // Bright Blue
];

// Seeded random number generator for deterministic cluster positions
function createSeededRNG(seed: number) {
  let s = seed;
  return function nextRandom() {
    s = (s * 9301 + 49297) % 233280;
    return s / 233280;
  };
}

function hexToRgb(hex: string) {
  const clean = hex.replace('#', '');
  const bigint = parseInt(clean, 16);
  return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
}

const fadeIn = keyframes`
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;

const PageWrapper = styled.div`
  min-height: 100vh;
  background: linear-gradient(180deg, #f5f7fa 0%, #e8ecf1 50%, #f5f7fa 100%);
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  margin: -2rem;
  padding: 0;
  color: #1a1a2e;

  @media (max-width: 991px) {
    margin: -1rem;
  }
`;

// Full-height hero section with particle animation
const HeroSection = styled.div`
  position: relative;
  height: 100vh;
  min-height: 500px;
  margin-top: 2rem;
  background: linear-gradient(180deg, #f0f4f8 0%, #e3eaf2 50%, #f0f4f8 100%);
  overflow: hidden;
  width: 100vw;
  margin-left: calc(-50vw + 50%);
  display: flex;
  align-items: center;
  justify-content: center;

  @media (max-width: 1024px) {
    min-height: 450px;
  }

  @media (max-width: 768px) {
    min-height: 400px;
    margin-top: 1rem;
  }

  @media (max-width: 480px) {
    min-height: 350px;
    margin-top: 0.5rem;
  }

  &::before {
    content: '';
    position: absolute;
    inset: 0;
    background-image:
      linear-gradient(0deg, rgba(59, 130, 246, 0.06) 1px, transparent 1px),
      linear-gradient(90deg, rgba(59, 130, 246, 0.06) 1px, transparent 1px);
    background-size: 40px 40px;
    z-index: 0;
    pointer-events: none;

    @media (max-width: 768px) {
      background-size: 30px 30px;
    }

    @media (max-width: 480px) {
      background-size: 20px 20px;
    }
  }

  canvas {
    position: absolute;
    inset: 0;
    z-index: 1;
  }

  .hero-content {
    position: relative;
    z-index: 10;
    text-align: center;
    padding: 2rem 1.5rem;
    max-width: 900px;

    @media (max-width: 768px) {
      padding: 1.5rem 1rem;
      max-width: 100%;
    }

    @media (max-width: 480px) {
      padding: 1rem 0.75rem;
    }
  }

  h1 {
    font-size: 4.5rem;
    font-weight: 700;
    color: #0f172a;
    margin-bottom: 1.5rem;
    line-height: 1.1;
    letter-spacing: -0.02em;
    animation: ${fadeIn} 1s ease-out;
    text-shadow: 0 1px 2px rgba(15, 23, 42, 0.1);

    @media (max-width: 1024px) {
      font-size: 3.5rem;
    }

    @media (max-width: 768px) {
      font-size: 2.5rem;
      margin-bottom: 1rem;
    }

    @media (max-width: 480px) {
      font-size: 1.8rem;
      margin-bottom: 0.75rem;
    }
  }

  .subtitle {
    font-size: 1.4rem;
    color: rgba(15, 23, 42, 0.75);
    margin-bottom: 2.5rem;
    line-height: 1.6;
    font-weight: 300;
    animation: ${fadeIn} 1s ease-out 0.2s both;

    @media (max-width: 1024px) {
      font-size: 1.2rem;
      margin-bottom: 2rem;
    }

    @media (max-width: 768px) {
      font-size: 1rem;
      margin-bottom: 1.5rem;
      line-height: 1.5;
    }

    @media (max-width: 480px) {
      font-size: 0.9rem;
      margin-bottom: 1rem;
      line-height: 1.4;
    }
  }

  .cta-buttons {
    display: flex;
    gap: 1.5rem;
    justify-content: center;
    animation: ${fadeIn} 1s ease-out 0.4s both;

    @media (max-width: 1024px) {
      gap: 1.25rem;
    }

    @media (max-width: 768px) {
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    @media (max-width: 480px) {
      gap: 0.75rem;
    }
  }
`;

const CTAButton = styled(Link)`
  padding: 1rem 2.5rem;
  font-size: 1.1rem;
  font-weight: 600;
  text-decoration: none;
  border-radius: 8px;
  transition: all 0.3s ease;
  display: inline-block;

  @media (max-width: 1024px) {
    padding: 0.9rem 2.2rem;
    font-size: 1rem;
  }

  @media (max-width: 768px) {
    padding: 0.85rem 2rem;
    font-size: 0.95rem;
    width: 100%;
    max-width: 300px;
  }

  @media (max-width: 480px) {
    padding: 0.75rem 1.5rem;
    font-size: 0.9rem;
    width: 100%;
    max-width: 100%;
  }

  &.primary {
    background: linear-gradient(135deg, #3b82f6, #1e40af);
    color: #fff;
    box-shadow: 0 4px 20px rgba(59, 130, 246, 0.35);

    &:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(59, 130, 246, 0.5);
      background: linear-gradient(135deg, #4f92f7, #2952cc);
    }

    @media (max-width: 480px) {
      &:hover {
        transform: translateY(-1px);
      }
    }
  }

  &.secondary {
    background: transparent;
    color: #1e40af;
    border: 2px solid rgba(59, 130, 246, 0.4);

    &:hover {
      background: rgba(59, 130, 246, 0.08);
      border-color: rgba(59, 130, 246, 0.7);
      box-shadow: 0 0 20px rgba(59, 130, 246, 0.2);
    }

    @media (max-width: 480px) {
      &:hover {
        background: rgba(59, 130, 246, 0.05);
      }
    }
  }
`;

interface Particle {
  x: number;
  y: number;
  baseX: number; // Original x position in grid
  baseY: number; // Original y position in grid
  vx: number;
  vy: number;
  radius: number;
  layer: number; // For depth/parallax layers
  parallaxOffsetX: number;
  parallaxOffsetY: number;
  pulse: number; // For pulsing glow effect
  pulseSpeed: number;
  clusterColor: string; // Color for this cluster
  clusterIdx: number; // Index of parent cluster
}

const MainContent: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const particlesRef = useRef<Particle[]>([]);
  const clusterCentersRef = useRef<{ x: number; y: number; color: string; nodeCount: number; radius: number; parallaxOffsetX: number; parallaxOffsetY: number }[]>([]);
  const animationFrameRef = useRef<number>();
  const mouseRef = useRef<{ x: number; y: number }>({ x: 0, y: 0 });
  const animationYOffsetRef = useRef<number>(0);
  const initializedRef = useRef(false); // Track if clusters have been initialized
  const lastCanvasSizeRef = useRef<{ width: number; height: number }>({ width: 0, height: 0 }); // Track last canvas size

  // Function to initialize/regenerate clusters and particles based on canvas size
  const initializeClusters = (canvas: HTMLCanvasElement) => {
    // Create a new RNG with the same seed for consistent positioning
    const nextRandom = createSeededRNG(42);
    
    // Initialize particles as clusters (several groups with spread and jitter)
    const clusterCount = 6; // number of clusters
    const particles: Particle[] = [];

    // Define cluster centers — spread across the full page, avoiding center text area and edges
    // Add 25px minimum margin from edges plus margin for cluster radius
    const edgeMargin = 25;
    const marginX = edgeMargin + canvas.width * 0.08;
    const marginY = edgeMargin + canvas.height * 0.08;
    const usableW = canvas.width - marginX * 2;
    const usableH = canvas.height - marginY * 2;
    
    // Exclude center area where hero text is (scale with viewport height) - expanded to push clusters to sides
    const centerExcludeRadius = Math.max(350, canvas.height * 0.4);
    
    const clusterCenters: { x: number; y: number; color: string; nodeCount: number; radius: number; parallaxOffsetX: number; parallaxOffsetY: number }[] = [];
    
    // Minimum distance between clusters to avoid overlapping but allow all 6 to fit
    const minCenterDist = Math.max(180, Math.min(canvas.width, canvas.height) * 0.12);
    
    for (let c = 0; c < clusterCount; c++) {
      let attempts = 0;
      let placed = false;
      while (attempts < 500 && !placed) {
        const cx = marginX + nextRandom() * usableW;
        const cy = marginY + nextRandom() * usableH;
        
        // Check distance from canvas center (avoid center text area)
        const distFromCenter = Math.sqrt((cx - canvas.width / 2) ** 2 + (cy - canvas.height / 2) ** 2);
        if (distFromCenter < centerExcludeRadius) {
          attempts++;
          continue;
        }
        
        let ok = true;
        for (const existing of clusterCenters) {
          const dx = existing.x - cx;
          const dy = existing.y - cy;
          if (Math.sqrt(dx * dx + dy * dy) < minCenterDist) {
            ok = false;
            break;
          }
        }
        if (ok) {
          // Vary node count per cluster (between 10 and 20 nodes each)
          const nodeCount = 10 + Math.floor(nextRandom() * 11);
          // Scale cluster radius based on screen size — reduced for smaller screens
          let baseClusterRadius = Math.min(canvas.width, canvas.height) * 0.1;
          
          // Reduce cluster sizes on smaller screens
          if (canvas.width < 768) {
            baseClusterRadius = Math.min(canvas.width, canvas.height) * 0.08;
          }
          if (canvas.width < 480) {
            baseClusterRadius = Math.min(canvas.width, canvas.height) * 0.06;
          }
          
          const clusterRadius = baseClusterRadius * (0.8 + nextRandom() * 0.8);
          
          // Verify cluster with its radius stays within bounds
          const clusterEdgeMargin = edgeMargin + clusterRadius;
          if (cx - clusterRadius < clusterEdgeMargin || 
              cx + clusterRadius > canvas.width - clusterEdgeMargin ||
              cy - clusterRadius < clusterEdgeMargin ||
              cy + clusterRadius > canvas.height - clusterEdgeMargin) {
            attempts++;
            continue; // Cluster too close to edge, try again
          }
          
          clusterCenters.push({
            x: cx,
            y: cy,
            color: CLUSTER_COLORS[c % CLUSTER_COLORS.length],
            nodeCount: nodeCount,
            radius: clusterRadius,
            parallaxOffsetX: 0,
            parallaxOffsetY: 0
          });
          placed = true;
        }
        attempts++;
      }
    }

    // Move clusters slightly upward to make space for the hero text/buttons
    const animationYOffset = -canvas.height * 0.06; // move up by 6% of height
    clusterCenters.forEach(c => { c.y += animationYOffset; });

    // Distribute particles into clusters with radial spread to avoid full overlap
    for (let clusterIdx = 0; clusterIdx < clusterCenters.length; clusterIdx++) {
      const cluster = clusterCenters[clusterIdx];
      for (let i = 0; i < cluster.nodeCount; i++) {
        // Use the cluster radius as the maximum distance for particles
        // Ensure particles stay strictly within the circle
        const maxRadius = cluster.radius * 0.65; // tighter constraint, particles closer to center
        const angle = nextRandom() * Math.PI * 2;
        const r = Math.sqrt(nextRandom()) * maxRadius; // radial distribution, clamped

        const baseX = cluster.x + Math.cos(angle) * r;
        const baseY = cluster.y + Math.sin(angle) * r;

        particles.push({
          x: baseX,
          y: baseY,
          baseX: baseX,
          baseY: baseY,
          vx: 0, // no movement
          vy: 0, // no movement
          radius: 2 + nextRandom() * 1.5,
          layer: (clusterIdx % 3) + 1,
          parallaxOffsetX: 0,
          parallaxOffsetY: 0,
          pulse: nextRandom() * Math.PI * 2,
          pulseSpeed: 0.02 + nextRandom() * 0.02,
          clusterColor: cluster.color,
          clusterIdx: clusterIdx
        });
      }
    }

    return { particles, clusterCenters, animationYOffset };
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Set initial canvas size
    const resizeCanvas = () => {
      const newWidth = window.innerWidth;
      const newHeight = window.innerHeight;
      
      canvas.width = newWidth;
      canvas.height = newHeight;
      
      // Only reinitialize clusters if they haven't been initialized or if viewport changed significantly (>10%)
      const lastSize = lastCanvasSizeRef.current;
      const widthChange = Math.abs(newWidth - lastSize.width) / lastSize.width;
      const heightChange = Math.abs(newHeight - lastSize.height) / lastSize.height;
      
      if (!initializedRef.current || widthChange > 0.1 || heightChange > 0.1) {
        const { particles, clusterCenters, animationYOffset } = initializeClusters(canvas);
        particlesRef.current = particles;
        clusterCentersRef.current = clusterCenters;
        animationYOffsetRef.current = animationYOffset;
        
        initializedRef.current = true;
        lastCanvasSizeRef.current = { width: newWidth, height: newHeight };
      }
    };
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Initial setup if not already done
    if (!initializedRef.current) {
      const { particles, clusterCenters, animationYOffset } = initializeClusters(canvas);
      particlesRef.current = particles;
      clusterCentersRef.current = clusterCenters;
      animationYOffsetRef.current = animationYOffset;
      initializedRef.current = true;
      lastCanvasSizeRef.current = { width: canvas.width, height: canvas.height };
    }

    // Track mouse position
    const handleMouseMove = (e: MouseEvent) => {
      mouseRef.current = { x: e.clientX, y: e.clientY };
    };
    window.addEventListener('mousemove', handleMouseMove);

    // Animation loop
    const animate = () => {
      // Light background with subtle fade for graph effect
      ctx.fillStyle = 'rgba(240, 244, 248, 0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw subtle grid lines for graph aesthetic
      const gridSize = 60;
      ctx.strokeStyle = 'rgba(59, 130, 246, 0.08)';
      ctx.lineWidth = 0.8;
      
      // Vertical grid lines
      for (let x = 0; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      // Horizontal grid lines
      for (let y = 0; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

  // Draw graph axes and labels
  const axisMargin = 60;
  const axisX = axisMargin;
  const axisY = canvas.height - axisMargin - Math.max(0, animationYOffsetRef.current); // move sync with animation shift
  const axisWidth = canvas.width - axisMargin * 1.5;
  const axisHeight = canvas.height - axisMargin * 1.5 + Math.max(0, animationYOffsetRef.current);

  // Draw bottom axis (feature x1)
  ctx.strokeStyle = 'rgba(30, 64, 175, 0.7)';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(axisX, axisY);
  ctx.lineTo(axisX + axisWidth, axisY);
  ctx.stroke();

  // Draw left axis (feature x2)
  ctx.beginPath();
  ctx.moveTo(axisX, axisY);
  ctx.lineTo(axisX, axisY - axisHeight);
  ctx.stroke();

  // Draw axis labels
  ctx.font = 'bold 14px Inter, sans-serif';
  ctx.fillStyle = 'rgba(30, 64, 175, 0.8)';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText('feature x1', axisX + axisWidth / 2, axisY + 15);

  ctx.save();
  ctx.translate(axisX - 30, axisY - axisHeight / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('feature x2', 0, 0);
  ctx.restore();

  // Parallax effect removed - clusters remain static at their positions
  
  // Update and draw particles
  // Draw cluster boundary circles
  clusterCentersRef.current.forEach(cluster => {
    const { r: cr, g: cg, b: cb } = hexToRgb(cluster.color);
    const cx = cluster.x;
    const cy = cluster.y + animationYOffsetRef.current;
    ctx.beginPath();
    ctx.arc(cx, cy, cluster.radius, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${cr}, ${cg}, ${cb}, 0.06)`; // subtle fill
    ctx.fill();
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = `rgba(${cr}, ${cg}, ${cb}, 0.3)`; // visible border
    ctx.stroke();
  });

  particlesRef.current.forEach((particle) => {
        // Particles move with their parent cluster (unified entity) - no parallax
        const gx = particle.x;
        const gy = particle.y + animationYOffsetRef.current;
        const glowRadius = particle.radius;

        const { r: nr, g: ng, b: nb } = hexToRgb(particle.clusterColor);
        
        // Outer glow (larger, visible on light background)
        const outerGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, glowRadius * 2.5);
        outerGrad.addColorStop(0, `rgba(${nr}, ${ng}, ${nb}, 0.2)`);
        outerGrad.addColorStop(0.5, `rgba(${nr}, ${ng}, ${nb}, 0.08)`);
        outerGrad.addColorStop(1, `rgba(${nr}, ${ng}, ${nb}, 0)`);
        ctx.fillStyle = outerGrad;
        ctx.fillRect(gx - glowRadius * 2.5, gy - glowRadius * 2.5, glowRadius * 5, glowRadius * 5);

        // Draw inner glow (smaller) using radial gradient
        const innerRadius = glowRadius * 0.8;
        const innerGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, innerRadius);
        innerGrad.addColorStop(0, `rgba(${nr}, ${ng}, ${nb}, 0.5)`);
        innerGrad.addColorStop(1, `rgba(${nr}, ${ng}, ${nb}, 0.08)`);
        ctx.fillStyle = innerGrad;
        ctx.fillRect(gx - innerRadius, gy - innerRadius, innerRadius * 2, innerRadius * 2);

        // Draw core square (bright and solid)
        const coreSize = particle.radius * 2.2;
        ctx.fillStyle = `rgba(${nr}, ${ng}, ${nb}, 0.85)`;
        ctx.fillRect(gx - coreSize / 2, gy - coreSize / 2, coreSize, coreSize);

        // Connections between nodes have been disabled per request — no lines are drawn here.
      });

      // Draw "k = 6" text in top right corner
      let labelFontSize = 18;
      if (canvas.width < 768) {
        labelFontSize = 14;
      }
      if (canvas.width < 480) {
        labelFontSize = 12;
      }
      
      ctx.font = `bold ${labelFontSize}px Inter, sans-serif`;
      ctx.fillStyle = 'rgba(30, 64, 175, 0.7)';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'top';
      ctx.fillText('k = 6', canvas.width - 30, 30);

      animationFrameRef.current = requestAnimationFrame(animate);
    };

    animate();

    return () => {
      window.removeEventListener('resize', resizeCanvas);
      window.removeEventListener('mousemove', handleMouseMove);
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, []);

  return (
    <PageWrapper>
      <HeroSection>
        <canvas ref={canvasRef} />
        <div className="hero-content">
          <h1>USC Machine Learning Center</h1>
          <p className="subtitle">
            Advancing the frontiers of machine learning research through interdisciplinary
            collaboration and innovative computational approaches to society's greatest challenges.
          </p>
          <div className="cta-buttons">
            <CTAButton to="/about" className="primary">Learn More</CTAButton>
            <CTAButton to="/labs" className="secondary">Research Labs</CTAButton>
          </div>
        </div>
      </HeroSection>
    </PageWrapper>
  );
};

export default MainContent;
