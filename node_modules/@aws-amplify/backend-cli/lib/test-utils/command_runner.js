import { AsyncLocalStorage } from 'node:async_hooks';
import { generateCommandFailureHandler } from '../error_handler.js';
import { extractSubCommands } from '../extract_sub_commands.js';
class OutputInterceptor {
    output = '';
    append = (chunk) => {
        this.output += chunk;
    };
    getOutput = () => this.output;
}
const asyncLocalStorage = new AsyncLocalStorage();
// Casting original write to Function to disable compiler safety intentionally.
// The process.stdout.write has many overloads and it's impossible to get right types here.
// We're passing unchanged argument list to original method, therefore this is safe.
// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
const createInterceptedWrite = (originalWrite) => {
    return (...args) => {
        const interceptor = asyncLocalStorage.getStore();
        if (interceptor && args.length > 0 && typeof args[0] === 'string') {
            interceptor.append(args[0]);
        }
        return originalWrite(...args);
    };
};
const originalStdoutWrite = process.stdout.write.bind(process.stdout);
process.stdout.write = createInterceptedWrite(originalStdoutWrite);
const originalStderrWrite = process.stderr.write.bind(process.stderr);
process.stderr.write = createInterceptedWrite(originalStderrWrite);
/**
 * An error that has both output and error that occurred during command execution.
 */
export class TestCommandError extends Error {
    error;
    output;
    /**
     * Creates new test command error.
     */
    constructor(error, output) {
        super();
        this.error = error;
        this.output = output;
    }
}
/**
 * Runs commands given preconfigured yargs parser.
 */
export class TestCommandRunner {
    parser;
    usageDataEmitter;
    /**
     * Creates new command runner.
     */
    constructor(parser, usageDataEmitter = {
        emitFailure: () => Promise.resolve(),
        emitSuccess: () => Promise.resolve(),
    }) {
        this.parser = parser;
        this.usageDataEmitter = usageDataEmitter;
        this.parser = parser
            // Pin locale
            .locale('en')
            // Override script name to avoid long test file names
            .scriptName('ampx')
            // Make sure we don't exit process on error or --help
            .exitProcess(false)
            // attach the failure handler
            // this is necessary because we may be testing a subcommand that doesn't have the top-level failure handler attached
            // eventually we may want to have a separate "testFailureHandler" if we need additional tooling here
            .fail(generateCommandFailureHandler(parser, this.usageDataEmitter));
    }
    /**
     * Runs a command. Returns command output or throws an error if command failed.
     */
    runCommand = async (args) => {
        const interceptor = new OutputInterceptor();
        try {
            // We are using AsyncLocalStorage and OutputInterceptor to capture stdout and stdin streams into memory
            // instead of using parse/parseAsync with callback.
            // The reasons are:
            // - parse/parseAsync with callback leaves orphan promises that trigger unhandledRejection handler in tests
            // - parse/parseAsync with callback have edge cases if command builder and handler methods are sync or async
            //   see https://github.com/yargs/yargs/issues/1069
            //   and https://github.com/yargs/yargs/blob/main/docs/api.md#parseargs-context-parsecallback
            // - callback can only capture yargs logger outputs. it can't capture messages emitted from our code
            //
            // AsyncLocalStorage is used to make sure that we're capturing outputs only from the same asynchronous context
            // in potentially concurrent environment.
            await asyncLocalStorage.run(interceptor, async () => {
                await this.parser.parseAsync(args);
                const metricDimension = {};
                const subCommands = extractSubCommands(this.parser);
                if (subCommands) {
                    metricDimension.command = subCommands;
                }
                await this.usageDataEmitter.emitSuccess({}, metricDimension);
            });
            return interceptor.getOutput();
        }
        catch (err) {
            throw new TestCommandError(err, interceptor.getOutput());
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbWFuZF9ydW5uZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGVzdC11dGlscy9jb21tYW5kX3J1bm5lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUVyRCxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNwRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUVoRSxNQUFNLGlCQUFpQjtJQUNiLE1BQU0sR0FBRyxFQUFFLENBQUM7SUFDcEIsTUFBTSxHQUFHLENBQUMsS0FBYSxFQUFFLEVBQUU7UUFDekIsSUFBSSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUM7SUFDdkIsQ0FBQyxDQUFDO0lBQ0YsU0FBUyxHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7Q0FDL0I7QUFFRCxNQUFNLGlCQUFpQixHQUFHLElBQUksaUJBQWlCLEVBQXFCLENBQUM7QUFFckUsK0VBQStFO0FBQy9FLDJGQUEyRjtBQUMzRixvRkFBb0Y7QUFDcEYsc0VBQXNFO0FBQ3RFLE1BQU0sc0JBQXNCLEdBQUcsQ0FBQyxhQUF1QixFQUFFLEVBQUU7SUFDekQsT0FBTyxDQUFDLEdBQUcsSUFBYSxFQUFFLEVBQUU7UUFDMUIsTUFBTSxXQUFXLEdBQ2YsaUJBQWlCLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDL0IsSUFBSSxXQUFXLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksT0FBTyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssUUFBUSxFQUFFO1lBQ2pFLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDN0I7UUFFRCxPQUFPLGFBQWEsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ2hDLENBQUMsQ0FBQztBQUNKLENBQUMsQ0FB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Z3MnO1xuaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2UgfSBmcm9tICdub2RlOmFzeW5jX2hvb2tzJztcbmltcG9ydCB7IFVzYWdlRGF0YUVtaXR0ZXIgfSBmcm9tICdAYXdzLWFtcGxpZnkvcGxhdGZvcm0tY29yZSc7XG5pbXBvcnQgeyBnZW5lcmF0ZUNvbW1hbmRGYWlsdXJlSGFuZGxlciB9IGZyb20gJy4uL2Vycm9yX2hhbmRsZXIuanMnO1xuaW1wb3J0IHsgZXh0cmFjdFN1YkNvbW1hbmRzIH0gZnJvbSAnLi4vZXh0cmFjdF9zdWJfY29tbWFuZHMuanMnO1xuXG5jbGFzcyBPdXRwdXRJbnRlcmNlcHRvciB7XG4gIHByaXZhdGUgb3V0cHV0ID0gJyc7XG4gIGFwcGVuZCA9IChjaHVuazogc3RyaW5nKSA9PiB7XG4gICAgdGhpcy5vdXRwdXQgKz0gY2h1bms7XG4gIH07XG4gIGdldE91dHB1dCA9ICgpID0+IHRoaXMub3V0cHV0O1xufVxuXG5jb25zdCBhc3luY0xvY2FsU3RvcmFnZSA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZTxPdXRwdXRJbnRlcmNlcHRvcj4oKTtcblxuLy8gQ2FzdGluZyBvcmlnaW5hbCB3cml0ZSB0byBGdW5jdGlvbiB0byBkaXNhYmxlIGNvbXBpbGVyIHNhZmV0eSBpbnRlbnRpb25hbGx5LlxuLy8gVGhlIHByb2Nlc3Muc3Rkb3V0LndyaXRlIGhhcyBtYW55IG92ZXJsb2FkcyBhbmQgaXQncyBpbXBvc3NpYmxlIHRvIGdldCByaWdodCB0eXBlcyBoZXJlLlxuLy8gV2UncmUgcGFzc2luZyB1bmNoYW5nZWQgYXJndW1lbnQgbGlzdCB0byBvcmlnaW5hbCBtZXRob2QsIHRoZXJlZm9yZSB0aGlzIGlzIHNhZmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1mdW5jdGlvbi10eXBlXG5jb25zdCBjcmVhdGVJbnRlcmNlcHRlZFdyaXRlID0gKG9yaWdpbmFsV3JpdGU6IEZ1bmN0aW9uKSA9PiB7XG4gIHJldHVybiAoLi4uYXJnczogbmV2ZXJbXSkgPT4ge1xuICAgIGNvbnN0IGludGVyY2VwdG9yOiBPdXRwdXRJbnRlcmNlcHRvciB8IHVuZGVmaW5lZCA9XG4gICAgICBhc3luY0xvY2FsU3RvcmFnZS5nZXRTdG9yZSgpO1xuICAgIGlmIChpbnRlcmNlcHRvciAmJiBhcmdzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnRlcmNlcHRvci5hcHBlbmQoYXJnc1swXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdpbmFsV3JpdGUoLi4uYXJncyk7XG4gIH07XG59O1xuY29uc3Qgb3JpZ2luYWxTdGRvdXRXcml0ZSA9IHByb2Nlc3Muc3Rkb3V0LndyaXRlLmJpbmQocHJvY2Vzcy5zdGRvdXQpO1xucHJvY2Vzcy5zdGRvdXQud3JpdGUgPSBjcmVhdGVJbnRlcmNlcHRlZFdyaXRlKG9yaWdpbmFsU3Rkb3V0V3JpdGUpO1xuXG5jb25zdCBvcmlnaW5hbFN0ZGVycldyaXRlID0gcHJvY2Vzcy5zdGRlcnIud3JpdGUuYmluZChwcm9jZXNzLnN0ZGVycik7XG5wcm9jZXNzLnN0ZGVyci53cml0ZSA9IGNyZWF0ZUludGVyY2VwdGVkV3JpdGUob3JpZ2luYWxTdGRlcnJXcml0ZSk7XG5cbi8qKlxuICogQW4gZXJyb3IgdGhhdCBoYXMgYm90aCBvdXRwdXQgYW5kIGVycm9yIHRoYXQgb2NjdXJyZWQgZHVyaW5nIGNvbW1hbmQgZXhlY3V0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVGVzdENvbW1hbmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgbmV3IHRlc3QgY29tbWFuZCBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGVycm9yOiBFcnJvcixcbiAgICByZWFkb25seSBvdXRwdXQ6IHN0cmluZyxcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnMgY29tbWFuZHMgZ2l2ZW4gcHJlY29uZmlndXJlZCB5YXJncyBwYXJzZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZXN0Q29tbWFuZFJ1bm5lciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIG5ldyBjb21tYW5kIHJ1bm5lci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcGFyc2VyOiBBcmd2LFxuICAgIHByaXZhdGUgdXNhZ2VEYXRhRW1pdHRlcjogVXNhZ2VEYXRhRW1pdHRlciA9IHtcbiAgICAgIGVtaXRGYWlsdXJlOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICAgIGVtaXRTdWNjZXNzOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSxcbiAgICB9LFxuICApIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlclxuICAgICAgLy8gUGluIGxvY2FsZVxuICAgICAgLmxvY2FsZSgnZW4nKVxuICAgICAgLy8gT3ZlcnJpZGUgc2NyaXB0IG5hbWUgdG8gYXZvaWQgbG9uZyB0ZXN0IGZpbGUgbmFtZXNcbiAgICAgIC5zY3JpcHROYW1lKCdhbXB4JylcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBleGl0IHByb2Nlc3Mgb24gZXJyb3Igb3IgLS1oZWxwXG4gICAgICAuZXhpdFByb2Nlc3MoZmFsc2UpXG4gICAgICAvLyBhdHRhY2ggdGhlIGZhaWx1cmUgaGFuZGxlclxuICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB3ZSBtYXkgYmUgdGVzdGluZyBhIHN1YmNvbW1hbmQgdGhhdCBkb2Vzbid0IGhhdmUgdGhlIHRvcC1sZXZlbCBmYWlsdXJlIGhhbmRsZXIgYXR0YWNoZWRcbiAgICAgIC8vIGV2ZW50dWFsbHkgd2UgbWF5IHdhbnQgdG8gaGF2ZSBhIHNlcGFyYXRlIFwidGVzdEZhaWx1cmVIYW5kbGVyXCIgaWYgd2UgbmVlZCBhZGRpdGlvbmFsIHRvb2xpbmcgaGVyZVxuICAgICAgLmZhaWwoZ2VuZXJhdGVDb21tYW5kRmFpbHVyZUhhbmRsZXIocGFyc2VyLCB0aGlzLnVzYWdlRGF0YUVtaXR0ZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIGEgY29tbWFuZC4gUmV0dXJucyBjb21tYW5kIG91dHB1dCBvciB0aHJvd3MgYW4gZXJyb3IgaWYgY29tbWFuZCBmYWlsZWQuXG4gICAqL1xuICBydW5Db21tYW5kID0gYXN5bmMgKGFyZ3M6IHN0cmluZyB8IEFycmF5PHN0cmluZz4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGNvbnN0IGludGVyY2VwdG9yID0gbmV3IE91dHB1dEludGVyY2VwdG9yKCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlIGFyZSB1c2luZyBBc3luY0xvY2FsU3RvcmFnZSBhbmQgT3V0cHV0SW50ZXJjZXB0b3IgdG8gY2FwdHVyZSBzdGRvdXQgYW5kIHN0ZGluIHN0cmVhbXMgaW50byBtZW1vcnlcbiAgICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgcGFyc2UvcGFyc2VBc3luYyB3aXRoIGNhbGxiYWNrLlxuICAgICAgLy8gVGhlIHJlYXNvbnMgYXJlOlxuICAgICAgLy8gLSBwYXJzZS9wYXJzZUFzeW5jIHdpdGggY2FsbGJhY2sgbGVhdmVzIG9ycGhhbiBwcm9taXNlcyB0aGF0IHRyaWdnZXIgdW5oYW5kbGVkUmVqZWN0aW9uIGhhbmRsZXIgaW4gdGVzdHNcbiAgICAgIC8vIC0gcGFyc2UvcGFyc2VBc3luYyB3aXRoIGNhbGxiYWNrIGhhdmUgZWRnZSBjYXNlcyBpZiBjb21tYW5kIGJ1aWxkZXIgYW5kIGhhbmRsZXIgbWV0aG9kcyBhcmUgc3luYyBvciBhc3luY1xuICAgICAgLy8gICBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lhcmdzL3lhcmdzL2lzc3Vlcy8xMDY5XG4gICAgICAvLyAgIGFuZCBodHRwczovL2dpdGh1Yi5jb20veWFyZ3MveWFyZ3MvYmxvYi9tYWluL2RvY3MvYXBpLm1kI3BhcnNlYXJncy1jb250ZXh0LXBhcnNlY2FsbGJhY2tcbiAgICAgIC8vIC0gY2FsbGJhY2sgY2FuIG9ubHkgY2FwdHVyZSB5YXJncyBsb2dnZXIgb3V0cHV0cy4gaXQgY2FuJ3QgY2FwdHVyZSBtZXNzYWdlcyBlbWl0dGVkIGZyb20gb3VyIGNvZGVcbiAgICAgIC8vXG4gICAgICAvLyBBc3luY0xvY2FsU3RvcmFnZSBpcyB1c2VkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlJ3JlIGNhcHR1cmluZyBvdXRwdXRzIG9ubHkgZnJvbSB0aGUgc2FtZSBhc3luY2hyb25vdXMgY29udGV4dFxuICAgICAgLy8gaW4gcG90ZW50aWFsbHkgY29uY3VycmVudCBlbnZpcm9ubWVudC5cbiAgICAgIGF3YWl0IGFzeW5jTG9jYWxTdG9yYWdlLnJ1bihpbnRlcmNlcHRvciwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLnBhcnNlci5wYXJzZUFzeW5jKGFyZ3MpO1xuICAgICAgICBjb25zdCBtZXRyaWNEaW1lbnNpb246IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICAgICAgY29uc3Qgc3ViQ29tbWFuZHMgPSBleHRyYWN0U3ViQ29tbWFuZHModGhpcy5wYXJzZXIpO1xuXG4gICAgICAgIGlmIChzdWJDb21tYW5kcykge1xuICAgICAgICAgIG1ldHJpY0RpbWVuc2lvbi5jb21tYW5kID0gc3ViQ29tbWFuZHM7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy51c2FnZURhdGFFbWl0dGVyLmVtaXRTdWNjZXNzKHt9LCBtZXRyaWNEaW1lbnNpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IuZ2V0T3V0cHV0KCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgVGVzdENvbW1hbmRFcnJvcihlcnIgYXMgRXJyb3IsIGludGVyY2VwdG9yLmdldE91dHB1dCgpKTtcbiAgICB9XG4gIH07XG59XG4iXX0=