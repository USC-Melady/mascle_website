import fsp from 'fs/promises';
import path from 'path';
import { printer } from '../../printer.js';
import { LogLevel } from '../../printer/printer.js';
/**
 * YarnModernLockFileReader is an abstraction around the logic used to read and parse lock file contents
 */
export class YarnModernLockFileReader {
    getLockFileContentsFromCwd = async () => {
        const eolRegex = '[\r\n]';
        const dependencies = [];
        const yarnLockPath = path.resolve(process.cwd(), 'yarn.lock');
        try {
            const yarnLockContents = await fsp.readFile(yarnLockPath, 'utf-8');
            const yarnLockContentsArray = yarnLockContents.split(new RegExp(`${eolRegex}${eolRegex}`));
            if (yarnLockContentsArray.length === 3) {
                // Contents are only comment block, metadata, and workspace info
                return { dependencies };
            }
            // Slice to remove comment block and metadata at the start of the lock file
            for (const yarnDependencyBlock of yarnLockContentsArray.slice(2)) {
                const yarnDependencyLines = yarnDependencyBlock
                    .trim()
                    .split(new RegExp(eolRegex));
                const yarnDependencyName = yarnDependencyLines[0];
                const yarnDependencyVersion = yarnDependencyLines[1];
                // Get dependency name before versioning info
                const dependencyName = yarnDependencyName
                    .slice(0, yarnDependencyName.lastIndexOf('@'))
                    .replaceAll(/"/g, '');
                const versionMatch = yarnDependencyVersion.match(/[\d.]+/);
                const dependencyVersion = versionMatch ? versionMatch[0] : '';
                dependencies.push({ name: dependencyName, version: dependencyVersion });
            }
        }
        catch {
            printer.log(`Failed to get lock file contents because ${yarnLockPath} does not exist or is not parse-able`, LogLevel.DEBUG);
            return;
        }
        return { dependencies };
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWFybl9tb2Rlcm5fbG9ja19maWxlX3JlYWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wYWNrYWdlLW1hbmFnZXItY29udHJvbGxlci9sb2NrLWZpbGUtcmVhZGVyL3lhcm5fbW9kZXJuX2xvY2tfZmlsZV9yZWFkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxHQUFHLE1BQU0sYUFBYSxDQUFDO0FBQzlCLE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUV4QixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRXBEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLHdCQUF3QjtJQUNuQywwQkFBMEIsR0FBRyxLQUFLLElBRWhDLEVBQUU7UUFDRixNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDMUIsTUFBTSxZQUFZLEdBQXNCLEVBQUUsQ0FBQztRQUMzQyxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUU5RCxJQUFJO1lBQ0YsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLEdBQUcsQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ25FLE1BQU0scUJBQXFCLEdBQUcsZ0JBQWdCLENBQUMsS0FBSyxDQUNsRCxJQUFJLE1BQU0sQ0FBQyxHQUFHLFFBQVEsR0FBRyxRQUFRLEVBQUUsQ0FBQyxDQUNyQyxDQUFDO1lBRUYsSUFBSSxxQkFBcUIsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUN0QyxnRUFBZ0U7Z0JBQ2hFLE9BQU8sRUFBRSxZQUFZLEVBQUUsQ0FBQzthQUN6QjtZQUVELDJFQUEyRTtZQUMzRSxLQUFLLE1BQU0sbUJBQW1CLElBQUkscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNoRSxNQUFNLG1CQUFtQixHQUFHLG1CQUFtQjtxQkFDNUMsSUFBSSxFQUFFO3FCQUNOLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUMvQixNQUFNLGtCQUFrQixHQUFHLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsRCxNQUFNLHFCQUFxQixHQUFHLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUVyRCw2Q0FBNkM7Z0JBQzdDLE1BQU0sY0FBYyxHQUFHLGtCQUFrQjtxQkFDdEMsS0FBSyxDQUFDLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7cUJBQzdDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ3hCLE1BQU0sWUFBWSxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDM0QsTUFBTSxpQkFBaUIsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2dCQUU5RCxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxDQUFDO2FBQ3pFO1NBQ0Y7UUFBQyxNQUFNO1lBQ04sT0FBTyxDQUFDLEdBQUcsQ0FDVCw0Q0FBNEMsWUFBWSxzQ0FBc0MsRUFDOUYsUUFBUSxDQUFDLEtBQUssQ0FDZixDQUFDO1lBQ0YsT0FBTztTQUNSO1FBRUQsT0FBTyxFQUFFLFlBQVksRUFBRSxDQUFDO0lBQzFCLENBQUMsQ0FBQztDQUNIIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVwZW5kZW5jeSB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IGZzcCBmcm9tICdmcy9wcm9taXNlcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IExvY2tGaWxlQ29udGVudHMsIExvY2tGaWxlUmVhZGVyIH0gZnJvbSAnLi90eXBlcy5qcyc7XG5pbXBvcnQgeyBwcmludGVyIH0gZnJvbSAnLi4vLi4vcHJpbnRlci5qcyc7XG5pbXBvcnQgeyBMb2dMZXZlbCB9IGZyb20gJy4uLy4uL3ByaW50ZXIvcHJpbnRlci5qcyc7XG5cbi8qKlxuICogWWFybk1vZGVybkxvY2tGaWxlUmVhZGVyIGlzIGFuIGFic3RyYWN0aW9uIGFyb3VuZCB0aGUgbG9naWMgdXNlZCB0byByZWFkIGFuZCBwYXJzZSBsb2NrIGZpbGUgY29udGVudHNcbiAqL1xuZXhwb3J0IGNsYXNzIFlhcm5Nb2Rlcm5Mb2NrRmlsZVJlYWRlciBpbXBsZW1lbnRzIExvY2tGaWxlUmVhZGVyIHtcbiAgZ2V0TG9ja0ZpbGVDb250ZW50c0Zyb21Dd2QgPSBhc3luYyAoKTogUHJvbWlzZTxcbiAgICBMb2NrRmlsZUNvbnRlbnRzIHwgdW5kZWZpbmVkXG4gID4gPT4ge1xuICAgIGNvbnN0IGVvbFJlZ2V4ID0gJ1tcXHJcXG5dJztcbiAgICBjb25zdCBkZXBlbmRlbmNpZXM6IEFycmF5PERlcGVuZGVuY3k+ID0gW107XG4gICAgY29uc3QgeWFybkxvY2tQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICd5YXJuLmxvY2snKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB5YXJuTG9ja0NvbnRlbnRzID0gYXdhaXQgZnNwLnJlYWRGaWxlKHlhcm5Mb2NrUGF0aCwgJ3V0Zi04Jyk7XG4gICAgICBjb25zdCB5YXJuTG9ja0NvbnRlbnRzQXJyYXkgPSB5YXJuTG9ja0NvbnRlbnRzLnNwbGl0KFxuICAgICAgICBuZXcgUmVnRXhwKGAke2VvbFJlZ2V4fSR7ZW9sUmVnZXh9YCksXG4gICAgICApO1xuXG4gICAgICBpZiAoeWFybkxvY2tDb250ZW50c0FycmF5Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAvLyBDb250ZW50cyBhcmUgb25seSBjb21tZW50IGJsb2NrLCBtZXRhZGF0YSwgYW5kIHdvcmtzcGFjZSBpbmZvXG4gICAgICAgIHJldHVybiB7IGRlcGVuZGVuY2llcyB9O1xuICAgICAgfVxuXG4gICAgICAvLyBTbGljZSB0byByZW1vdmUgY29tbWVudCBibG9jayBhbmQgbWV0YWRhdGEgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsb2NrIGZpbGVcbiAgICAgIGZvciAoY29uc3QgeWFybkRlcGVuZGVuY3lCbG9jayBvZiB5YXJuTG9ja0NvbnRlbnRzQXJyYXkuc2xpY2UoMikpIHtcbiAgICAgICAgY29uc3QgeWFybkRlcGVuZGVuY3lMaW5lcyA9IHlhcm5EZXBlbmRlbmN5QmxvY2tcbiAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgLnNwbGl0KG5ldyBSZWdFeHAoZW9sUmVnZXgpKTtcbiAgICAgICAgY29uc3QgeWFybkRlcGVuZGVuY3lOYW1lID0geWFybkRlcGVuZGVuY3lMaW5lc1swXTtcbiAgICAgICAgY29uc3QgeWFybkRlcGVuZGVuY3lWZXJzaW9uID0geWFybkRlcGVuZGVuY3lMaW5lc1sxXTtcblxuICAgICAgICAvLyBHZXQgZGVwZW5kZW5jeSBuYW1lIGJlZm9yZSB2ZXJzaW9uaW5nIGluZm9cbiAgICAgICAgY29uc3QgZGVwZW5kZW5jeU5hbWUgPSB5YXJuRGVwZW5kZW5jeU5hbWVcbiAgICAgICAgICAuc2xpY2UoMCwgeWFybkRlcGVuZGVuY3lOYW1lLmxhc3RJbmRleE9mKCdAJykpXG4gICAgICAgICAgLnJlcGxhY2VBbGwoL1wiL2csICcnKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbk1hdGNoID0geWFybkRlcGVuZGVuY3lWZXJzaW9uLm1hdGNoKC9bXFxkLl0rLyk7XG4gICAgICAgIGNvbnN0IGRlcGVuZGVuY3lWZXJzaW9uID0gdmVyc2lvbk1hdGNoID8gdmVyc2lvbk1hdGNoWzBdIDogJyc7XG5cbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goeyBuYW1lOiBkZXBlbmRlbmN5TmFtZSwgdmVyc2lvbjogZGVwZW5kZW5jeVZlcnNpb24gfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICBwcmludGVyLmxvZyhcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgbG9jayBmaWxlIGNvbnRlbnRzIGJlY2F1c2UgJHt5YXJuTG9ja1BhdGh9IGRvZXMgbm90IGV4aXN0IG9yIGlzIG5vdCBwYXJzZS1hYmxlYCxcbiAgICAgICAgTG9nTGV2ZWwuREVCVUcsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB7IGRlcGVuZGVuY2llcyB9O1xuICB9O1xufVxuIl19